#Redis概念

[TOC]

##持久化机制
Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化；当Redis重启之后通过把硬盘文件重新加载到内存达到恢复数据的目的。
实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

Redis持久化方式：RDB(Redis Database) 和 AOF(Append-Only File)
- RDB持久化方式：可以在指定时间间隔内生成数据集的时间点快照(point-in-time snapshot)；
- AOF持久化方式：它记录了服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集；
- AOF文件中的命令全部以Rediscover协议的格式来保存，新命令会被追加到文件的末尾；Redis还可以在后台对AOF文件进行重写，使得AOF文件的体积不会超出保存数据集状态所需的实际大小；
- Redis还可以同时使用AOF和RDB，此种情况下，Redis重启时会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整；
- 甚至可以关闭持久化功能，让数据只在服务器运行时存在。
###RDB
- RDB的优点
1. RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集；
2. RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。
3. RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
4. RDB在恢复大数据集时的速度比AOF的恢复速度要快。

- RDB的缺点
1. 如果你需要尽量避免在服务器故障时丢失数据，那么RDB不适合你。虽然Redis允许你设置不同的保存点（save point）来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少5分钟才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能会丢失好几分钟的数据；
2. 每次保存RDB的时候，Redis 都要fork()出一个子进程，并由子进程来进行实际的持久化工作。在数据集比较庞大时，fork()可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。虽然AOF重写也需要进行fork()，但无论AOF重写的执行间隔有多长，数据的耐久性都不会有任何损失。

###AOF
- AOF的优点
1. 使用AOF持久化会让Redis变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无fsync，每秒钟一次fsync，或者每次执行写入命令时fsync。AOF的默认策略为每秒钟fsync一次，在这种配置下，Redis仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求）;
2. AOF文件是一个只进行追加操作的日志文件（append only log），因此对AOF文件的写入不需要进行seek，即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等），redis-check-aof 工具也可以轻易地修复这种问题;
3. Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写：重写后的新 AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新AOF文件的过程中，会继续将命令追加到现有的AOF文件里面，即使重写过程中发生停机，现有的AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作;
4. AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export）AOF文件也非常简单：举个例子，如果你不小心执行了FLUSHALL命令，但只要AOF文件未被重写，那么只要停止服务器，移除AOF文件末尾的FLUSHALL命令，并重启Redis，就可以将数据集恢复到FLUSHALL执行之前的状态。

- AOF的缺点
1. 对于相同的数据集来说,AOF文件的体积通常要大于RDB文件的体积;
2. 根据所使用的fsync策略，AOF的速度可能会慢于RDB。在一般情况下，每秒fsync的性能依然非常高，而关闭fsync可以让AOF的速度和RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间（latency）;
3. AOF在过去曾经发生过这样的bug ：因为个别命令的原因，导致AOF文件在重新载入时，无法将数据集恢复成保存时的原样.（举个例子，阻塞命令BRPOPLPUSH source destination timeout 就曾经引起过这样的bug）测试套件里为这种情况添加了测试：它们会自动生成随机的、复杂的数据集，并通过重新载入这些数据来确保一切正常。虽然这种bug在AOF文件中并不常见，但是对比来说，RDB几乎是不可能出现这种bug的。

##缓存雪崩
- 原有缓存失效，新缓存未准备好；
（例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。）
- 解决办法：大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开。

##缓存穿透
- 缓存穿透是指缓存数据没有命中，数据库中的数据也没有命中，并且出于容错考虑，数据库查询不到的数据不写入缓存，导致每次查询都都要到数据库中查询（相当于进行了两次无用的查询），失去了缓存的意义。

- 解决办法：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。
5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？
对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。
Bitmap：典型的就是哈希表
缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。
布隆过滤器（推荐）
就是引入了k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。
Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。

##缓存击穿
- 缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。
- 解决方案：在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

##缓存预热
- 系统上线后，将相关的缓存数据直接加载到缓存中，避免用户查询时直接访问数据库。
- 解决方案：
1. 直接写个缓存刷新页面，上线时手动操作；
2. 数据量不大时，可以在项目启动时候自动加载；
3. 定时刷新缓存。

##缓存更新
除了系统自带缓存失效策略之外，还可以根据业务需求自定义缓存淘汰策略，常见策略有两种：
- 定期清理；（缺点是维护大量缓存数据的key比较麻烦）
- 当有用户请求过来时，在判断请求用到的缓存数据是否已经过期，过期的话就从数据库从新获取最新数据并更新缓存。(缺点是逻辑复杂)

##缓存降级
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。
参考日志级别设置预案：
- 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
- 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
- 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
- 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

##过期策略
Redis的过期策略是指当 缓存中的key过期了，Redis如何处理：
过期策略通常有三种：
- 定时过期：每个设置过期时间的key都需要创建一个定时器，时间到了立即清除；（该策略可以立即清除过期数据，对内存友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量）
- 惰性过期：当访问一个key时，才会判断该key是否过期，过期则清除；（该策略可以最大化地节省CPU资源，对内存非常不友好 ；极端情况可能会出现大量过期key没有被再次访问而不会被清除，占用内存）
- 定期过期：每隔一段时间扫描数据库的expires字典中一定数量的key，并清除其中已经过期的key；（该策略是前两者的折中方案，通过调整 定期扫描的时间间隔 和 每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果；expires字典会保存所有设置了过期时间的key的过期时间数据，key是指向键空间中的某个键的指针，value是该键的毫秒精度的过期时间。）

Redis中同时使用了 惰性过期 和 定期过期 两种过期策略。

##内存淘汰策略
Redis内存淘汰策略（缓存失效策略）是指在缓存不足时，怎么处理需要新写入且需要申请空间的数据。
Redis默认有6中策略可供选择：
1. noeviction：新写入操作会报错；
2. allkeys-lru：移除最近最少使用的key；
3. allkeys-random：随机移除某个key；
4. volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key；
5. volatile-random：在设置了过期时间的键空间中，随机移除某个key；
6. volatile-ttl：在设置了过期时间的键空间中，优先移除更早过期时间的key；
-------
在redis.conf中有一行配置：maxmemory-policy volatile-lru
-------
Redis的内存淘汰策略的选取 并不会影响 过期key的处理，内存淘汰策略 用于处理内存不足时的需要申请额外空间的数据，而过期策略 用于处理过期的缓存数据。

##Memcache 与 Redis的区别
1. 存储方式：Memcache数据存储在内存中，断电丢数据，数据量不能超出内存；Redis有持久化机制；
2. 数据类型的支持：Memcache所有的值均是简单的字符串；Redis支持丰富的数据类型；
3. 底层模型不同：他们的 底层实现方式 以及 与客户端之间的通信协议不一样；Redis直接自己构建VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
4. value值大小不同：Redis最大可支持512MB， Memcache只有1MB；
5. Redis比Memcache速度快；
6. Redis支持数据的备份，即master-slave模式的数据备份。

##单线程的Redis为什么这么快
- 纯内存操作；
- 单线程操作，避免了频繁的上下文切换；
- 采用非阻塞IO多路复用机制。

##支持的数据类型以及应用场景
1. String
最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
2. hash
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。例如在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
3. list
使用List的数据结构，可以做简单的消息队列的功能；另外可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。一个很合适的场景：获取行情信息，也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。
4. set
set存放的是一堆不重复值的集合，所以可以做全局去重的功能。
- 为什么不用JVM自带的Set进行去重？
- 因为系统一般都是集群部署，使用JVM自带的Set，为了一个全局去重，再起一个公共服务，太麻烦；
- 另外，可以利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

5. sorted set
集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。

##Redis内部结构
Redis本质上是一个数据结构服务器(data structure server)，Redis的数据结构可能需要从两个不同层次上讨论：
- 第一个层面是从使用者角度：上述的5中数据类型；
- 第二个层面是从内部实现的角度，属于更底层的实现。

Redis是通过组合第二层面的各种基础数据接哦股来实现第一层次的更高层次的数据结构。


第二层的内部结构包括：
- ![dict](./redis-2dict.md)
- ![sds](./redis-3sds.md)
- ![ziplist](./redis-4ziplist.md)
- ![quicklist](./redis-5quicklist.md)
- ![skiplist](./redis-6skiplist.md)



